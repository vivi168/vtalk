/**
* @file server.c
* @author Vivien Bihl
* @version 1.0
*
* @section LICENSE
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 2 of the
* License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details at
* http://www.gnu.org/copyleft/gpl.html
*
* @section DESCRIPTION
* ./server port_number
* Multi users chat room server
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAXCON 68 
#define NAMESIZ 20 // max name length 
#define MSGSIZ 1004 // message size

struct clientinfo{
	char name[NAMESIZ]; // nickname
	int sd; // socket 	
};

int main(int argc, char **argv)
{	
	int sockfd; // listener
	int sockfd2; // accept + recv
	int i, j;
	int nbytes; // size of the received message, if 0 -> EOF notif
	int nbcon = 4; // current number of clients connected start at 4 because of socfd et sockfd2
	int fdmax;
	
	socklen_t addrlen;
	char buf[BUFSIZ];
	char msgbuf[MSGSIZ];
	char namebuf[NAMESIZ];
	struct sockaddr_in6 my_addr;
	struct sockaddr_in6 client;
	struct clientinfo ci[MAXCON]; // array of clients	
	fd_set master;
	fd_set read_fds;


	// check the number of args on command line
	if(argc != 2)
	{
		printf("USAGE: %s port_num\n", argv[0]);
		exit(-1);
	}

	// socket factory
	if((sockfd = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) == -1)
	{
		perror("error socket");
		exit(EXIT_FAILURE);
	}

	// init local addr structure and other params
	my_addr.sin6_family	= AF_INET6;
	my_addr.sin6_port = htons(atoi(argv[1]));
	my_addr.sin6_addr = in6addr_any;
	addrlen	= sizeof(struct sockaddr_in6);
	memset(buf,'\0',1024);

	// bind addr structure with socket
	if(bind(sockfd, (struct sockaddr*)&my_addr, addrlen) == -1)
	{
		perror("error bind");
		close(sockfd);
		exit(EXIT_FAILURE);
	}
	
	FD_ZERO(&master);
	FD_ZERO(&read_fds);

	if(listen(sockfd, 10) == -1)
	{
		perror("error listen");
		close(sockfd);
		exit(EXIT_FAILURE);
	}
	//add the listener to the master set
	FD_SET(sockfd, &master);

	//keep track of the biggest file descriptor
	fdmax = sockfd;

	//main loop
	while(1)
	{
		read_fds = master;
		if(select(fdmax + 1, &read_fds, NULL, NULL, NULL) == -1)
		{
			perror("select");
			close(sockfd);
			close(sockfd2);
			exit(EXIT_FAILURE);
		}
		for(i=0; i <= fdmax; i++)
		{
			if(FD_ISSET(i, &read_fds))
			// cycles through existing connections
			{
				if(i == sockfd)
				// got a match
				{
					if(nbcon < MAXCON)
					{
						if((sockfd2 = accept(sockfd, (struct sockaddr*)&client, &addrlen)) == -1)
						// handle new connection
						{
							perror("error accept");
						}
						else
						{
							FD_SET(sockfd2, &master); // add to master set
							if(sockfd2 > fdmax)
							// keep track of the max
							{
								fdmax = sockfd2;
							}

							if(recv(sockfd2, namebuf, NAMESIZ, 0) == -1)
							{
								perror("recv name");
							}
							else
							//store informations
							{
								strcpy(ci[nbcon].name, namebuf);
								ci[nbcon].sd = sockfd2;
								printf("%s has connected\n", ci[nbcon].name);
								nbcon++;
							}
						}
					}
				}
				
				else
				// handle data from a client
				{
					if((nbytes = recv(i, msgbuf, MSGSIZ, 0)) == -1)
					// got an error or connection closed by client
					{
						if(nbytes == 0)
						// connection closed
						{
							printf("socked %d disconnected", i);
						}
						else
						// error
						{
							perror("recv message");
						}
						close(i);
						FD_CLR(i, &master);
					}
					else
					// we got data from client
					{
						for(j = 0; j <= fdmax; j++)
						// send message to everyone except listener and ourselves
						{
							if(FD_ISSET(j, &master))
							{
								if(j != sockfd && j != i)
								{
									strcpy(buf, msgbuf);
									strcat(buf, ci[i].name);
									printf("%s %s\n", ci[i].name, msgbuf);
									if(send(j, buf, BUFSIZ, 0) == -1)
									{
										perror("send message");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	// close sockets
	close(sockfd);
	close(sockfd2);

	return 0;
}
